% TODO: Extract to settings.tex

% Variables and other equation stuff
\newcommand{\Q}{\bm{Q}}
\newcommand{\gradQ}{\gradient{\Q}}
\newcommand{\Qrho}{\rho}
\newcommand{\Qj}{\rho \bm{v}}
\newcommand{\Qv}{\bm{v}}
\newcommand{\QE}{\rho E}
\newcommand{\QZZ}{Z} % TODO: Name?
\newcommand{\QZ}{\rho \QZZ}
\newcommand{\potT}{\theta}
\newcommand{\backgroundPotT}{\overline{\theta}}
\newcommand{\pertubationPotT}{\theta'}
\newcommand{\stressT}{\bm{\sigma}}
\newcommand{\pressure}{p}
\newcommand{\maxConvEigen}[1][]{
  \vert%
  \lambda_c^{\text{max}}
  \notblank{#1}{\left(#1\right)}{}
  \vert%
}
\newcommand{\maxViscEigen}[1][]{
  \vert%
  \lambda_v^{\text{max}}
  \notblank{#1}{\left(#1\right)}{}
  \vert%
}
\newcommand{\Riemann}{\operatorname{Riemann}}

% Stuff for numerics
\newcommand{\domain}{\Omega}
\newcommand{\broken}{\domain}
\newcommand{\cell}[1][i]{C_{#1}}
\newcommand{\boundary}{\partial \domain}
\newcommand{\sbasis}[1]{\Phi_{#1}}
\newcommand{\stbasis}[1]{\Phi_{#1}}
\newcommand{\testfunction}[1]{\Phi_{#1}}
\newcommand{\normal}{\bm{n}}
\newcommand{\dsol}[1][h]{\bm{u}_{#1}}
\newcommand{\stpredictor}[1][h]{\bm{q}_{#1}}

% Equation parts
\newcommand{\flux}{F}
\newcommand{\viscFlux}{\flux^{v}}
\newcommand{\hyperFlux}{\flux^{h}}
\newcommand{\source}{\bm{S}}

% Integrals
\newcommand{\intdt}[1]{\int_{t^n}^{t^{n+1}} #1 \dd{t}}
\newcommand{\intdcell}[1]{\int_{\cell} #1 \dd{\bm{x}}}
\newcommand{\intdcellb}[1]{\int_{\partial{} \cell} #1 \dd{S}} % TODO: define boundary of cell


\chapter{An ADER-DG scheme for the Navier-Stokes Equations}\label{chap:methods}
\section{Conservative Form}
Standard (hyperbolic) form of conservation law
\begin{equation}
  \label{eq:conservation-law}
 \frac{\partial}{\partial_t}  \Q + \div \flux(\Q) = \source(\bm{x}, t, \Q)
\end{equation}
extend to:
\begin{equation}
  \label{eq:conservation-law-gradient}
 \frac{\partial}{\partial_t}  \Q + \div \flux(\Q, \gradQ) = \source(\bm{x}, t, \Q)
\end{equation}

\section{The ADER-DG Method}
\label{sec:ader-dg}
We describe the arbitrary derivative discontinous Galerkin (ADER-DG) method in this chapter.
See: \cite{dumbser2018efficient}

We discuss the solution of a hyperbolic conservation law \cref{eq:conservation-law} with domain $\domain$ and boundary $boundary$.
In the discontinous Galerkin (DG) framework, we approximate this solution in the space
\begin{equation}
  \label{eq:dg-space}
  \broken = \bigcup_i \cell
\end{equation}
of disjoint quadrilateral cells $\cell$.
Note that we do not distinguish between the approximation space and the domain, the use should be clear given its surrounding context.
In the following we make use of the Einstein summation convention where summation over repeated indexes is implied.

Inside each cell $\cell$ we represent the solution in terms of the basis function 
\begin{equation}
  \label{eq:cell-approx}
  u(\bm{x}, t^n)_{|\cell[i]} = \hat{u}^n_{i,l} \sbasis{l}(\bm{x}),
\end{equation}
where $l$ is a multi-index, containing one index per spatial dimension.
\todo{dofs $\hat{u}$, local solution, etc.}
For example, $(l = (l_1, l_2))$ for the two dimensional case.
This polynomial is interpolating, i.e.\ \ldots\todo{interpolating?}.
This choice of basis (called \textit{nodal} basis) allows us to easily compute integrals over cells using Gaussian quadrature.
In detail, we use a the Lagrange interpolation polynomials.

We now describe the derivation of the \textsc{ader-dg} method.
This scheme is a predictor-corrector method.
We first compute a local solution of the cell in the predictor step and then connect with the neighbors in the corrector step.
In the following we first describe the corrector step as it follows directly from the \textsc{pde}.
The predictor is derived shortly after.

\begin{algorithm}[H]
  \begin{algorithmic}
    \Let{$\stpredictor$}{Initial guess}
    \Let{$F_h$}{$\flux(\Q, \gradQ)$}
    \Let{$\stpredictor$}{Solve \cref{eq:space-time-predictor} using $F_h, \Q, \gradQ$}
    \Let{$\left( \hat{F_h}, \hat{\Q}, \hat{\gradQ}, \hat{\stpredictor} \right)$}
        {Extrapolate to boundary using \cref{eq:boundary-extrapolation}}
    \Let{update}{Use \cref{eq:corrector} with boundary extrapolated values (fluxes of neighbors)}
  \end{algorithmic}
  \caption{The \textsc{ader-dg} algorithm for one cell.}
\end{algorithm}

\sidetitle{Corrector}
First, we multiply the system \cref{eq:conservation-law} by a test function $\testfunction{i}$ and integrate over the space-time volume $(\cell \times [t^n, t^{n+1}])$.
We arrive at the so called weak formulation of the \textsc{pde} 
\begin{equation}
  \label{eq:weak-pde}
\intdt{\intdcell{
\testfunction{k} \pdv{\Q}{t}
}}
+
\intdt{\intdcell{
    \testfunction{k} \left( \div{F(\Q, \gradQ} \right)
}}
=
\intdt{\intdcell{
    \testfunction{k} S(\Q, \bm{x}, t)
}}
\end{equation}
\todo{Include gradient everywhere!}
\todo{Double check the following description}
We now replace the solution $\bm{Q}$ with so called spacetime-predictor $\stpredictor (\bm{x},t)$ into the weak form and write it as a polynomial using the representation of \cref{eq:cell-approx}.
Integrate first by parts in time (note basis here not defined over time), flux divergence by parts in space.
\begin{align}
\begin{split}
\label{eq:corrector}
\left(
\intdcell{
  \testfunction{k} \sbasis{l}
}
\right)
(\bm{u^{n+1} - u^{n}})
&+
\left(\intdt{\intdcell{
      \testfunction{k} \Riemann(\stpredictor^-, \stpredictor^+) \cdot \normal
}}\right)
-\\
\left(\intdt{\intdcell{
    \gradient{\testfunction{k}} \cdot  \flux(\stpredictor)
}}\right)
&=
\left(\intdt{\intdcell{
      \testfunction{k} \source(\stpredictor)
}}\right)
\end{split}
\end{align}
The first term motivates an orthogonal basis as this leads to a diagonal mass matrix.

\sidetitle{Predictor}
To derive the predictor, we again take an approximation of our solution in a nodal basis, but now consider polynomials that are defined both in space and time
\begin{equation}
  \label{eq:cell-approx-space-time}
  q(\bm{x}, t^n)_{|\cell[i]} = \hat{u}^n_{i,l} \stbasis{l}(\bm{x}, t).
\end{equation}
We now multiply the conservation law again by a test function (of the same function space as the basis) and arrive at the weak formulation
\begin{equation}\label{eq:weak-pde-space-time}
\intdt{\intdcell{
    \testfunction{k}(\bm{x}, t)
    \pdv{\stpredictor}{t}
}}
+
\intdt{\intdcell{
    \testfunction{k}(\bm{x}, t)
    \left(
      \divergence{\flux(\stpredictor)}
    \right)
}}
=
\intdt{\intdcell{
  \testfunction{k} \source(\stpredictor)
}}.
\end{equation}
Similar to the derivation of the corrector, we again integrate the first term by parts in time and the flux divergence in space.
This time we do not use the Riemann solver for the flux boundary term but rather use the discrete solution at time $t$.
Note that this neglects the interaction with neighbouring cells; this is corrected in the corrector step.
\todo{Replace $\bm{x}$ with a macro some other letter. Is also coordinate!}

\begin{align}\label{eq:space-time-predictor}
\begin{split}
\intdcell{
  \testfunction{k} (\bm{x}, t^{n+1}) \stpredictor(\bm{x}. t^{n+1})
}
&-
\intdt{\intdcell{
    \pdv{}{d} \testfunction{k}(\bm{x}, t) \stpredictor(\bm{x}, t)
}}
-
\intdcell{
  \testfunction{k}(\bm{x},t^n) \dsol(\bm{x}, t^n)
} = \\
\intdt{\intdcell{
    \testfunction{k}(\bm{x},t) \divergence{\flux(\stpredictor)}
}}
&+
\intdt{\intdcell{
    \testfunction{k}(\bm{x}, t) \source(\stpredictor)
}}
\end{split}
\end{align}
Inserting \cref{eq:cell-approx-space-time} results in a local systems of equations that can be solved in a fixed point iteration scheme.
\todo{Inital guess correct? Maybe cite sth?}
As initial value for the space-time-predictor we use the solution of the timestep before.
\todo{Maybe collect into matrices and show scheme?}
For details and proof of convergence for the linear case, see~\cite{dumbser2008unified}.

\sidetitle{Boundary extrapolation and stuff}
\todo{Explain that stpredictor and fluxes are saved and extrapolated to boundary.
This is important because we extrapolate the gradient as well!}
Extrapolate unknowns to boundary, convert from our basis to basis on faces and so on

\sidetitle{Riemann solver \textit{\&} timestep}
As a Riemann solver we use a simple Rusanov-flux that is adapted for diffusive problems
\begin{equation}
  \label{eq:rusanov-flux}
  \Riemann(q_h^-, \nabla q_h^-; g_h^+, \nabla q_h^+) \cdot \bm{n} =
  \frac{1}{2} \left(
    F(q_h^+, \nabla q_h^+) +
    F(q_h^-, \nabla q_h^-)
  \right) -
  \frac{1}{2} s_\text{max} (q_h^+ - q_h^-),
\end{equation}
with a penalty term
\begin{equation}
  \label{eq:parabolic-penalty}
  s_\text{max}  = \max \left(
\maxConvEigen[q_h^-], \, \maxConvEigen[q_h^+]
\right) +
2 \eta \max \left(
\maxViscEigen[q_h^-], \, \maxViscEigen[q_h^+]
\right)
\end{equation}
and
\begin{equation}
  \eta = \frac{2N+1}{h \sqrt{\frac{1}{2} \pi}}.
\end{equation}
In this equation, $N$ is the polynomial order and $h$ is the side-length of an element.
The penalty term depends on the maximal absolute eigenvalues of both the convective and viscous part of the equations
\begin{align}
  \begin{split}
    \maxConvEigen &= \left( \partial \bm{F}/\partial \bm{Q}\right) \cdot \normal,\\
    \maxViscEigen &= \left( \partial \bm{F}/\partial \left( \nabla \bm{Q} \cdot \normal \right)\right) \cdot \normal,
  \end{split}
\end{align}
in direction of the normal vector $\normal$ to the cell face. 

This Riemann solver was first published in~\cite{gassner2008discontinuous} and used for an \textsc{ader-dg} scheme in~\cite{dumbser2010arbitrary}.
The timestep is restriced to a so-called \textsc{cfl}-type penalty
\begin{equation}
 \Delta t \leq  \text{CFL} \, \frac{\alpha(N) \, h}{\maxConvEigen + 2 \maxViscEigen \frac{2N+1}{h}}
\end{equation}
with $N$ polynomial order and $h$ characteristic length scale of elements~\cite{dumbser2010arbitrary,gassner2008discontinuous}.
The constant $\alpha(N) \leq {\left( 2N+1  \right)}^{-1}$ is obtained from von Neumann analysis on a simple model problem and depends on the approximation order~\cite{dumbser2008unified}.
We use a value of $0.7$ for the constant $\text{CFL}$.
\todo{Describe CFL-cond.\ for multiple dimensions!}


\section{Reactive Compressible Navier Stokes Equations}
Fluid motion can be described by the compressible Navier Stokes equations.
We follow the description in~\cite{dumbser2010arbitrary} for the Navier Stokes part.
The coupling with the advection-diffusion-reaction equation follows~\cite{hidalgo2011ader} which describes this equation set for the one-dimensional case.

The vector of conserved quantities is given by
\begin{equation}
  \label{eq:conserved-variables}
 \Q = \left( \Qrho, \Qj, \QE, \QZ \right),
\end{equation}
where $\Qrho$ is the density, $\Qj$ is the momentum, $\QE$ the energy density and $\QZ$ is the mass fraction of the chemical reactant.

We split the flux into a hyperbolic part $\hyperFlux(\Q)$ and an viscous flux $\viscFlux(\gradQ)$
\begin{equation}
  \label{eq:flux}
  \flux(\Q, \gradQ) = \hyperFlux(\Q) + \viscFlux(\Q, \gradQ).
\end{equation}

\newcommand{\diffCoeff}{\varepsilon}
\newcommand{\hyperFluxDef}{
  \begin{pmatrix}
    \Qj \\
    \Qv  \otimes \Qj + \bm{I} \pressure  \\
    \Qv \cdot (\bm{I} \QE + \bm{I} \pressure) \\
    \Qj \QZZ
  \end{pmatrix}
}

\newcommand{\viscFluxDef}{
  \begin{pmatrix}
     -\diffCoeff \gradient{\Qrho}\\
     \stressT (\Q, \gradQ)  \\
     \Qv \cdot \stressT (\Q, \gradQ) - \kappa \gradient{T}\\
     -\diffCoeff \gradient{\QZ}
   \end{pmatrix}
}

The hyperbolic flux is given by
\begin{equation}
  \label{eq:hyper-flux}
  \hyperFlux(\Q) = \hyperFluxDef,
\end{equation}
which are the Euler equations coupled with an advection equation.
The viscous flux is
\begin{equation}
  \label{eq:visc-flux}
  \viscFlux(\Q, \gradQ) = \viscFluxDef.
\end{equation}
where $\pressure$, $\stressT$ and $(\kappa \nabla T)$ denote the pressure, stress tensor and heat flux respectively.
Temperature is denoted by $T$.


Putting everything together, our complete \textsc{pde} is a conservation law of the form of \cref{eq:conservation-law-gradient}
\begin{equation}
 \begin{array}{l}
 \text{mass cons.} \\
 \text{momentum cons.} \\
 \text{energy cons.} \\
 \text{cont.\ gas} 
\end{array}
:
\quad
  \pdv{}{t}
  \underbrace{
  \begin{pmatrix}
    \Qrho\\
    \Qj\\
    \QE\\
    \QZ
    \end{pmatrix}}_{\Q}
  + 
  \divergence{
  \left(
   \underbrace{\hyperFluxDef}_{\hyperFlux(\Q)}
+
\underbrace{\viscFluxDef}_{\viscFlux(\Q, \gradQ)}
  \right)}
 =
  \underbrace{
  \begin{pmatrix}
    S_{\Qrho\phantom{\Qrho}}\\
    S_{\Qj}\\
    S_{\QE}\\
    S_{\QZ}
    \end{pmatrix}}_{\source(\Q, \bm{x}, t)}
\end{equation}

We close the system with the equation of state of an ideal reacting gas
\begin{equation}
  \label{eq:eos}
  \pressure = (\gamma - 1) \left(\QE - \frac{1}{2} \left(\Qv \cdot \Qj \right)  - q_0 \QZ \right).
\end{equation}
The term $q_0 \QZ$ corresponds to the chemical energy, where $q_0$ is the heat release.
The temperature $T$ relates to pressure and density by the ideal gas law
\begin{equation}
  \label{eq:temperature}
 \frac{\pressure}{\Qrho} = RT,
\end{equation}
where $R$ is the specific gas constant.

We further introduce the ratio of specific heats $\gamma$ and the heat fraction for constant volume $c_v$ and constant volume $c_r$.
These constants are all fluid dependent and relate to each other by
\begin{align}
  \label{eq:fluid-constants}
  \begin{split}
  c_v &= \frac{1}{\gamma - 1} R \\
  c_p &= \frac{\gamma}{\gamma - 1} R\\
  R &= c_p - c_v\\
  \gamma &= \frac{c_p}{c_v}.
  \end{split}
\end{align}
\todo{Cite sth!}
We can finally define the heat conduction coefficient $\kappa$
\begin{equation}
  \label{eq:heat-conduction-coeff}
  \kappa = \frac{\mu \gamma}{\Pr} \frac{1}{\gamma - 1} R = \frac{\mu \gamma}{\Pr} c_v
\end{equation}
where Prandtl number $\Pr$ again depends on the fluid.

% Sutherland's viscosity law:
% \begin{equation}
%   \label{eq:sutherland}
%  \mu(T)  = \mu_0 {\left(\frac{T}{T_0}  \right)}^{\beta} \frac{T_0 + C}{T + C}
% \end{equation}
% with \(\beta = 1.5\), \(C = \text{const.}\), reference temperature $T_0$ and reference viscosity $\mu_=$.
% Equal to
% \begin{align}
%   \lambda &= \frac{\mu_0 (T_0 + C)}{T_0^\beta} \\
%   \mu(T) &= \lambda \frac{T^\beta}{T + C},
% \end{align}
% where $\lambda$ is constant for a given fluid.

The viscous effects are modeled by the stress tensor
\begin{equation}
  \label{eq:stress-tensor}
  \stressT(Q, \nabla Q) =
  \mu
  \left(
  \left(\nicefrac{2}{3} \divergence{\Qv} \right) -
  \left( \gradient{\Qv} + \gradient{\Qv}^\intercal \right)
  \right).
\end{equation}

The maximal eigenvalues for convective and viscous part are
\begin{align}
  \maxConvEigen \vert  &= \Vert \Qv \Vert + c\\
  \maxViscEigen \vert &= \max \left( \frac{4}{3} \frac{\mu}{\Qrho},
                        \frac{\gamma \mu}{\Pr \Qrho},
                        \diffCoeff \right)
\end{align}
with speed of sound $c = \sqrt{\gamma R T }$.

\section{Boundary conditions}
To close the system we need to impose boundary conditions.

For some scenarios we use Cauchy boundary conditions.
In most cases, we would like to impose periodic boundary conditions, due to the inner workings of ExaHyPE this is not possible.
Instead we use the analytical solution of our problems at the boundary, imposing both value and gradients of the conservative variables.
Note that this leads to an error when our problem does not posses an exact analytical solution.
This is the case for test cases that are analytical solutions to the incompressible Navier Stokes equations but do not satisfy the compressible equation set.

As a physical boundary condition we limit ourselves to the no-slip boundary condition, where we assume that the fluid has a velocity of zero near the wall.
\todo{Check if this is the correct physical description!}
We enfore this by setting
\begin{align}
  \label{eq:no-slip}
  \begin{split}
  \Qrho^o &= \Qrho^i, \\
  \Qj^o &= -\Qj^i, \\
  \QE^0 &= \QE^i,\\
  {(\nabla Q)}^o &= {(\nabla Q)}^i,
  \end{split}
\end{align}
where a superscript of $o$ and $i$ denotes the values outside and inside of the boundary respectively.

\section{Adaptive Mesh Refinement \textit{\&} Finite Volume Limiting}\label{sec:grid}
Grid, spacefilling curve, and so on.

\subsection{Adaptive Mesh Refinement}\label{sec:amr}
We use adaptive mesh refinement (\textsc{amr}).

We use the total variation (\textsc{tv}) over an arbitrary indicator variable given by
\begin{equation}
  \label{eq:tv}
  \operatorname{TV}\left[ f(\bm{x}] \right] =
\Vert \left(\intdcell{ \vert \gradient{f \left( \bm{x} \right)} \vert } \right) \Vert_1
\end{equation}

\newcommand{\gobs}{\operatorname{G}}
\newcommand{\mean}{\mu}
\newcommand{\std}{\sigma}
\newcommand{\variance}{\std^2}
\newcommand{\gobsCount}{n}
We want to compute the mean and the variance over all grid cells by performing only pairwise merge operations.
This allows us to minimize communication over nodes and allows for a simple implementation.
The simplest way to compute this would be by using the textbook definitions of mean and variance of a random variable $X$
\newcommand{\expectation}{\mathbb{E}}
\begin{align}
  \begin{split}
    \mu [X] &= \expectation \left[ X \right]\\
    \variance [X] &= \expectation \left[ X^2 \right] - \expectation \left[ X \right]^2.
  \end{split}
\end{align}
The reduction for the variance is numerically unstable when the variance is orders of magnitudes smaller than the mean as this can lead to catastrophic cancellations.
We thus compute the mean and variance with the parallel algorithm of~\cite{chan1982updating}.
To do this, we need to store three variables per computation unit:
the mean, the variance and the number of processed elements.
We collect these items in the vector $\gobs = (\mean, \variance, \gobsCount)$
We can then merge two pairs of observed variables by \cref{alg:merge-variance}.

\begin{algorithm}[ht]
  \begin{algorithmic}
% TODO: Special cases 
\Function{reduce-variance}{$\gobs_0, \gobs_1$}
\If{$\gobsCount_0 = 0$}
  \State\Return{$\mean_1, \variance_1, \gobsCount_1$}
\EndIf\
\If{$\gobsCount_1 = 0$}
  \State\Return{$\mean_0, \variance_0, \gobsCount_0$}
\EndIf\
  \Let{$\Delta$}{$\mean_1 - \mean_0$}  
  \Let{$\gobsCount_\Sigma$}{$\gobsCount_0 + \gobsCount_1$}
  \Let{$m_a$}{$\variance_0 (\gobsCount_0 - 1)$}
  \Let{$m_b$}{$\variance_1 (\gobsCount_1 - 1)$}
  \Let{$m_\Sigma$}{$\nicefrac{m_a + m_b + (\Delta^2 \gobsCount_0 \gobsCount_1)}{\gobsCount_\Sigma}$}
  \Let{$\mean_\Sigma$}{$\mean_0  \gobsCount_0 + \mean_1 \gobsCount_1$}
  \State\Return{$
    \nicefrac{\mean_\Sigma}{\gobsCount_\Sigma},
    \nicefrac{m_\text{total}}{\gobsCount_\Sigma - 1},
    \gobsCount_\Sigma
    $}
\EndFunction\
  \end{algorithmic}
  \caption{\label{alg:merge-variance}
    Merging two sets of reduced mean and variance~\cite{chan1982updating}}
\end{algorithm}
We then use a threshold criterion
\todo{Cite Chebychev, add concrete form of threshold.}
This criterion can be justified by Chebychev's inequality, which states that
\begin{equation}
  \label{eq:chebychev}
  \mathbb{P}(\vert X - \mu \vert \geq c \sigma) \leq \frac{1}{c^2}
\end{equation}
for an arbitrary distribution with mean $\mu$ and standard deviation $\sigma$ probability $\mathbb{P}$.

\subsection{Limiting}\label{sec:limiting}
Higher order \textsc{dg} methods cannot cope with discontinuous solutions.
Even worse, in the case of non-linear fluxes, discontinuities can appear even from smooth initial data.
A classical way of dealing with this problem is the usage of so called limiters.
The idea is to smooth out steep gradients and thus eliminate discontinuities.\todo{It doesnt work like this exactly..}

A relatively recent way of dealing with this problem is the finite volume subcell limiter.
Our discussion follows the one in~\cite{dumbser2016simple}.
This limiting is an a posteriori limiting, which means that we first evaluate a timestep with an unlimited \textsc{ader-dg} method and then check, whether our solution is \enquote{correct}.
In our case, we check whether the solution is a valid floating point number.
We also check whether it is physically admissible.
In our case we use the criterion
\begin{equation}
  \label{eq:limiting-physical}
  \operatorname{is-admissible}(\Q) =
  \begin{cases}
    \text{true} & \Qrho > 0 \land \pressure > 0 \land \QZ > 0\\
    \text{false} & \text{otherwise}.
  \end{cases}
\end{equation}
The positivity of the pressure implies positivity of energy.
\todo{Mention dmp if I end up using it.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
